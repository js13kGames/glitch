<!DOCTYPE html>
<html>
<head>
	<title>Glitch</title>
	<style type="text/css">
		* {
			margin: 0;
			padding: 0;
			background-color: black;
		}
		html, body {
			height: 100%;
			width: 100%;
		}
		canvas {
			display: block;
		}
	</style>
</head>
<body>
	<canvas id="glitch"></canvas>
	<script type="text/javascript">
		var canvas = document.getElementById('glitch');
		var context = canvas.getContext('2d');
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

		var player = new Player();
		var border = new Border();
		var obs = [];
		var bar = new Bar();
		var pressCkeck = false;
		var connRadius = 100;

		setInterval(world,30);
		generateObs(100);

		window.addEventListener("keypress", function(e){
			if (e.keyCode >= 49 && e.keyCode <= 49+(player.hands).length-1
				&& !pressCkeck && !player.isMorphing) {
				player.morphTo(e.keyCode-49);
				pressCkeck = true;
			}
		});

		function generateObs(count) {
			for (var i = 0; i < count; i++) obs.push(new Obstacle());
		}

		function clearCanvas() {
			context.fillStyle = "#000";
			context.fillRect(0,0,canvas.width,canvas.height);
		}

		function randomBetween(min,max) {
			return Math.floor((Math.random()*(max - min)+min));
		}

		function getHypothenuse(x1,y1,x2,y2) {
  			var x = Math.abs(x1-x2);
  			var y = Math.abs(y1-y2);
  			return Math.sqrt((x*x)+(y*y));
		}

		drawConnection = function() {
			for (var i = 0; i < obs.length; i++) {
				for (var j = i+1; j < obs.length; j++) {
					if (getHypothenuse(
					obs[i].x,obs[i].y,
					obs[j].x,obs[j].y) <= connRadius) {
						context.strokeStyle = "rgba(255,55,55,"
					+Math.abs((getHypothenuse(
					obs[i].x,obs[i].y,
					obs[j].x,obs[j].y))
					-connRadius)*(1/connRadius)+
					")";
						context.beginPath();
						context.moveTo(obs[i].x,obs[i].y);
						context.lineTo(obs[j].x,obs[j].y);
						context.stroke();
					}
				}
			}
		}

		function world() {
			clearCanvas();
			if (pressCkeck) pressCkeck = false;
			player.update().draw();
			drawConnection();
			for (var i = 0; i < obs.length; i++) obs[i].update().draw();
			bar.update().draw();
			border.update().draw();
		}

		function Player() {
			this.x = canvas.width/4; 
			this.y = canvas.height/2;

			this.handGap = 50;
			this.radius = 20;
			this.iR = this.radius;

			this.isMorphing = false;
			this.morphIndex = -1;

			this.generateHands = function() {
				this.hands = [];
				for (var i = 0; i < 4; i++) {
					(this.hands).push(new Hand(this.handGap*(i+1)));
				}
			}; this.generateHands();

			this.morphTo = function(i) {
				if ((this.hands)[i].x - this.radius > border.xgap &&
					(this.hands)[i].y - this.radius > border.ygap &&
					(this.hands)[i].x + this.radius < canvas.width-border.xgap &&
					(this.hands)[i].y + this.radius < canvas.height-border.ygap &&
					!(this.hands)[i].isLoading) {

					this.morphIndex = i;
					this.isMorphing = true;
				}
			}

			this.glitchTo = function(i) {
				(this.hands)[i].used(this.x,this.y);
				this.x = (this.hands)[i].swp_x;
				this.y = (this.hands)[i].swp_y;
			}

			this.update = function() {
				if (this.isMorphing) {
					this.radius--;
					(this.hands)[this.morphIndex].radius++;
					if (this.radius <= 0+(this.hands)[this.morphIndex].iR) {
						this.glitchTo(this.morphIndex);
						this.isMorphing = false;
						this.radius = this.iR;
						(this.hands)[this.morphIndex].radius = 
							(this.hands)[this.morphIndex].iR;
						this.morphIndex = -1;
					}
				}
				for (var i = 0; i < (this.hands).length; i++)
					(this.hands)[i].update(this);
				return this;
			}

			this.draw = function() {
				for (var i = 0; i < (this.hands).length; i++)
					(this.hands)[i].draw();	
				
				context.strokeStyle = "#444";
				context.fillStyle = "#000";
				context.beginPath();
				context.arc(this.x,this.y,this.iR,Math.PI*2,false);
				context.fill();
				context.stroke();

				context.fillStyle = "#fff";
				context.beginPath();
				context.arc(this.x,this.y,this.radius,Math.PI*2,false);
				context.fill();
			}
		}

		function Hand(len) {
			this.angle = randomBetween(0,360);
			this.speed = randomBetween(-2,2);
			if (this.speed == 0) this.speed = 1;
			this.op = 1;
			this.isLoading = false;
			this.isOut = false;
			this.regen = 0.01;
			this.radius = 5;
			this.iR = this.radius;

			this.swp_x;this.swp_y;

			this.checkPos = function() {
				if (this.x - (this.p).radius < border.xgap ||
					this.y - (this.p).radius < border.ygap ||
					this.x + (this.p).radius > canvas.width-border.xgap ||
					this.y + (this.p).radius > canvas.height-border.ygap) {
					this.isOut = true;
				}
				else this.isOut = false;
			}

			this.used = function(x,y) {
				this.swp_x = this.x;
				this.swp_y = this.y;
				this.angle -= 180;
				this.x=x;
				this.y=y;
				this.op = 0;
				this.isLoading = true;
				this.speed = randomBetween(-2,2);
				if (this.speed == 0) this.speed = 1;
			}

			this.update = function(p) {
				this.p = p;
				this.checkPos();

				this.x = (this.p).x;
				this.y = (this.p).y;
				var dx = Math.cos(this.angle * (Math.PI/180)) * len;
				var dy = Math.sin(this.angle * (Math.PI/180)) * len;
				this.x += dx;
				this.y += dy;

				if (!(this.p).isMorphing) this.angle += this.speed;

				if (this.angle >= 360) {
					this.angle = 360 - this.angle;
				}

				if (this.isLoading) {
					this.op+=this.regen;
				}
				if (this.op >= 1) {
					this.isLoading = false;
				}

				return this;
			}

			this.draw = function() {

				context.strokeStyle = "#111";
				context.beginPath();
				context.moveTo((this.p).x,(this.p).y);
				context.lineTo(this.x,this.y);
				context.stroke();

				context.strokeStyle = "rgba(255,255,255,"+this.op/3+")";
				context.fillStyle = "rgba(255,255,255,"+this.op+")";

				if (!this.isLoading && !this.isOut) {
					context.fillStyle = "rgba(0,0,0,1)";
					context.beginPath();
					context.arc(this.x,this.y,(this.p).radius,Math.PI*2,false);
					context.arc(this.x,this.y,this.radius,Math.PI*2,false);
					context.fill();
					context.strokeStyle = "rgba(255,255,255,0.3)";
					context.fillStyle = "rgba(0,0,0,1)";
					context.beginPath();
					context.arc(this.x,this.y,(this.p).iR,Math.PI*2,false);
					context.stroke();
					context.fill();
				}

				context.fillStyle = "rgba(255,255,255,"+this.op+")";
				context.beginPath();
				context.arc(this.x,this.y,this.radius,Math.PI*2,false);
				context.fill();
			}
		}

		function Border() {
			this.xgap = 0;
			this.ygap = 50;

			this.update = function() {
				return this;
			}

			this.draw = function() {
				context.strokeStyle = "#555";
				context.strokeRect(this.xgap,this.ygap,
					canvas.width-this.xgap*2,canvas.height-this.ygap*2);
			}
		}

		function Obstacle() {
			this.x = randomBetween(canvas.width/1.5,canvas.width*1.5);
			this.y = randomBetween(0,canvas.height);
			this.radius = randomBetween(5,25);
			this.speed = randomBetween(1,3);
			this.minangle = 180 - randomBetween(0,45);
			this.maxangle = 180 + randomBetween(0,45);
			this.angle = randomBetween(this.minangle,this.maxangle);
			this.isRightSwing = true;
			if (randomBetween(0,2) == 0) {this.isRightSwing = false}

			this.control = function(){
				if (this.y-this.radius > canvas.height) {this.y = 0-this.radius;}
				else if (this.y+this.radius < 0) {this.y = canvas.height+this.radius;}
				if (this.x+this.radius < 0) {
					this.x = canvas.width+this.radius;
					this.y = randomBetween(0,canvas.height);
					this.radius = randomBetween(5,25);
				}
			}

			this.move = function() {
				if (this.isRightSwing) {
					this.angle--;
					if (this.angle <= this.minangle) {this.isRightSwing = false;}
				}
				else if (!this.isRightSwing) {
					this.angle++;
					if (this.angle >= this.maxangle) {this.isRightSwing = true;}
				}

				var dx = Math.cos(this.angle * (Math.PI / 180)) * this.speed;
		        var dy = Math.sin(this.angle * (Math.PI / 180)) * this.speed;

		        this.x += dx;
		        this.y += dy;
			}


			this.update = function() {
				this.control();
				this.move();
				if (getHypothenuse(this.x,this.y,player.x,player.y) < 
					this.radius+player.radius) {
					bar.deduct();
				}
				return this;
			}

			this.draw = function() {

				context.fillStyle = "rgba(255,0,0,1)";
				context.beginPath();
				context.arc(this.x,this.y,this.radius,Math.PI*2,false);
				context.fill();
			}
		}

		function Bar() {
			this.w = canvas.width/2; 
			this.h = 3;
			this.x = canvas.width/2 - this.w/2;
			this.y = border.ygap - this.h/2;
			this.progress = 0;
			this.error = false;
			this.message;
			var bugVal = randomBetween(0,100);

			this.deduct = function() {
				if (this.progress > 0) this.progress-=2;
				this.error = true;
			}

			this.setProcessMessage = function() {
				this.message = "PROCESS... Analyzing Foreign BubbleBugx"+bugVal+" ...";
				if (randomBetween(0,10) == 1) this.message = 
					"PROCESS... Glitching Portals m.e."+bugVal+"% going fine...";
			}

			this.setErrorMessage = function() {
				this.message = "ERROR... access to 04?:Jsk-66604:192.168.45.16 denied!";
					if (randomBetween(0,20) == 1) this.message = 
						"ERROR... BubbleBugx:66604:progress terminated";
			}

			this.update = function() {
				if (this.progress < this.w) this.progress+=0.1;
				if (randomBetween(0,10) == 1) bugVal = randomBetween(-100,1000);
				return this;
			}

			this.draw = function() {
				context.strokeStyle = "#aaa";
				context.fillStyle = "#fff";
				if (randomBetween(0,10)==1) this.setProcessMessage();
				if (this.error) {
					context.fillStyle = "#f00";
					context.strokeStyle = "#f00";
					this.setErrorMessage();
				}
				context.strokeRect(this.x,this.y,this.w,this.h);
				context.fillRect(this.x,this.y,this.progress,this.h);

				context.font = "10px Arial";
				context.fillText(this.message,this.x,this.y-this.h);

				var percentage = parseFloat(((this.progress/this.w)*100)).toFixed(5)+" %";
				context.font = "10px Arial";
				context.fillText(percentage,this.x+this.w-context.measureText(percentage).width,this.y-this.h);

				this.error = false;
			}
		}

		function Object() {
			this.x = 1; 
			this.y = 1;

			this.update = function() {
				return this;
			}

			this.draw = function() {
				
			}
		}
	</script>
</body>
</html>